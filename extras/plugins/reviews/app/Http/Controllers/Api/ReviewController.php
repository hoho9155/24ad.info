<?php

namespace extras\plugins\reviews\app\Http\Controllers\Api;

use App\Http\Controllers\Api\BaseController;
use App\Http\Resources\EntityCollection;
use App\Http\Resources\PostResource;
use App\Models\Post;
use App\Models\Scopes\ReviewedScope;
use App\Models\Scopes\VerifiedScope;
use extras\plugins\reviews\app\Http\Requests\ReviewRequest;
use extras\plugins\reviews\app\Http\Resources\ReviewResource;
use extras\plugins\reviews\app\Models\Review;

/**
 * @group Reviews
 */
class ReviewController extends BaseController
{
	/**
	 * List reviews
	 *
	 * @bodyParam postId int required The post's ID. Example: 2
	 *
	 * @param $postId
	 * @return \Illuminate\Http\JsonResponse
	 */
	public function index($postId): \Illuminate\Http\JsonResponse
	{
		// Get all reviews that are not spam for the product and paginate them
		$reviews = Review::query()->where('post_id', $postId)->approved()->notSpam();
		
		$embed = explode(',', request()->query('embed'));
		
		if (in_array('post', $embed)) {
			$reviews->with('post');
		}
		if (in_array('user', $embed)) {
			$reviews->with('user');
		}
		
		// Sorting
		$reviews = $this->applySorting($reviews, ['created_at']);
		
		$reviews = $reviews->paginate($this->perPage);
		
		// If the request is made from the app's Web environment,
		// use the Web URL as the pagination's base URL
		$reviews = setPaginationBaseUrl($reviews);
		
		$collection = collect();
		$reviewResourceClass = '\extras\plugins\reviews\app\Http\Resources\ReviewResource';
		if (class_exists($reviewResourceClass)) {
			$collection = new EntityCollection($reviewResourceClass, $reviews);
		}
		
		$message = ($reviews->count() <= 0) ? t('no_reviews_found') : null;
		
		return apiResponse()->withCollection($collection, $message);
	}
	
	/**
	 * Store review
	 *
	 * @authenticated
	 * @header Authorization Bearer {YOUR_AUTH_TOKEN}
	 *
	 * @bodyParam post_id int required The listing's ID. Example: null
	 * @bodyParam user_id int The logged user's ID. Example: null
	 * @bodyParam comment string required The review's message. Example: null
	 * @bodyParam rating int required The review's rating. Example: 4
	 * @bodyParam captcha_key string Key generated by the CAPTCHA endpoint calling (Required when the CAPTCHA verification is enabled from the Admin panel).
	 *
	 * @urlParam postId int required The listing's ID. Example: null
	 *
	 * @param $postId
	 * @param \extras\plugins\reviews\app\Http\Requests\ReviewRequest $request
	 * @return \Illuminate\Http\JsonResponse
	 */
	public function store($postId, ReviewRequest $request): \Illuminate\Http\JsonResponse
	{
		// Get Post
		$post = Post::query()->withoutGlobalScopes([VerifiedScope::class, ReviewedScope::class])->find($postId);
		if (empty($post)) {
			return apiResponse()->notFound(t('post_not_found'));
		}
		
		// Instantiate Rating model & Save it
		$review = new Review();
		$review->post_id = $post->id;
		$review->user_id = (auth('sanctum')->check()) ? auth('sanctum')->user()->getAuthIdentifier() : 0;
		$review->comment = $request->input('comment');
		$review->rating = $request->input('rating');
		$review->save();
		
		// Recalculate ratings for the specified listing
		$post->recalculateRating();
		
		$data = [
			'success' => true,
			'message' => trans('reviews::messages.review_posted'),
			'result'  => (new ReviewResource($review))->toArray($request),
			'extra' => [
				'post' => (new PostResource($post))->toArray($request),
			],
		];
		
		return apiResponse()->json($data);
	}
	
	/**
	 * Delete review(s)
	 *
	 * NOTE: Let's consider that only the reviews of the same listings can be deleted in bulk.
	 *
	 * @authenticated
	 * @header Authorization Bearer {YOUR_AUTH_TOKEN}
	 *
	 * @urlParam postId int required The listing's ID. Example: null
	 * @urlParam ids string required The ID or comma-separated IDs list of review(s).
	 *
	 * @param $postId
	 * @param $ids
	 * @return \Illuminate\Http\JsonResponse
	 */
	public function destroy($postId, $ids): \Illuminate\Http\JsonResponse
	{
		$authUser = auth('sanctum')->user();
		if (empty($authUser)) {
			return apiResponse()->unauthorized();
		}
		
		$data = [
			'success' => false,
			'message' => t('no_deletion_is_done'),
			'result'  => null,
		];
		
		$extra = [];
		
		// Get Entries ID (IDs separated by comma accepted)
		$ids = explode(',', $ids);
		
		// Delete
		$res = false;
		foreach ($ids as $reviewId) {
			$review = Review::query()->where('id', $reviewId);
			if (!$authUser->hasAllPermissions(\App\Models\Permission::getStaffPermissions())) {
				$review->where('user_id', $authUser->getAuthIdentifier());
			}
			$review->first();
			
			if (!empty($review)) {
				$res = $review->delete();
			}
		}
		
		// Recalculate ratings for the specified listing
		$extra['post'] = [];
		if (!empty($postId)) {
			$post = Post::query()
				->withoutGlobalScopes([VerifiedScope::class, ReviewedScope::class])
				->find($postId);
			
			if (!empty($post)) {
				$post->recalculateRating();
			}
			
			$extra['post'] = (new PostResource($post))->toArray(request());
		}
		
		// Confirmation
		if ($res) {
			$data['success'] = true;
			
			$count = count($ids);
			if ($count > 1) {
				$data['message'] = t('x entities have been deleted successfully', [
					'entities' => mb_strtolower(trans('reviews::messages.Reviews')),
					'count'    => $count,
				]);
			} else {
				$data['message'] = t('1 entity has been deleted successfully', [
					'entity' => mb_strtolower(trans('reviews::messages.Review')),
				]);
			}
		}
		
		$data['extra'] = $extra;
		
		return apiResponse()->json($data);
	}
}
